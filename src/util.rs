//! This module contains various utilities/helper functions

use itertools::Itertools;
use clap::{ClapError, ClapErrorType,};
use std::io::{BufRead, Write, BufWriter,};
use std::ptr;
use std::mem;
use std::borrow::Cow;
use super::Joinkit;

/// Converts a record separator to a single byte
pub fn rec_sep_as_byte(rec_str: &str) -> Result<u8, ClapError> {
    let bytes = rec_str.as_bytes();
    if bytes.len() == 1 {
        return Ok(bytes[0]);
    } else {
        let e = ClapError {error: "Error: input record separator must be encodable to 1 byte
        exactly!".to_owned(),
                           error_type: ClapErrorType::ValueValidationError,};
        return Err(e);
    }
}

/// Parses a string containing the fields indices in base1 and tries to convert them into vector of
/// 2-element tuples.
///
/// Each tuple contains the parsed field index and its position, both in base0. The association
/// with position is necessary, since the field indices will be sorted (to facilitate the key
/// extraction in `extract_key()` function) and thus might loose the info about their correct
/// position.
///
/// The resulting vector is sorted on the field indices. The error is returned if the input string
/// contains duplicate fieled indices.
///
/// # Example
/// ```
/// use joinkit::util;
///
/// // does not need to be ordered
/// let field_str = "1,3,6,4";
/// let field_idx = util::fields_to_idx(field_str).unwrap();
///
/// // this reads as follows: the first field goes to the first position, the third field goes to
/// // the second position, the fourth field goes to the fourth position and the sixth field goes
/// // to the third position.
/// assert_eq!(vec![(0, 0), (2, 1), (3, 3), (5, 2)], field_idx);
pub fn fields_to_idx(f: &str) -> Result<Vec<(usize, isize)>, ClapError> {
    let mut idx: Vec<(usize, isize)> = Vec::new();
    let it = f.split(',')
              .map(|s| s.parse::<usize>())
              .enumerate();
    for (i, r) in it {
        match r {
            // convert from base 1 to base 0
            Ok(u) => idx.push((u - 1, i as isize)),
            Err(_) => {
                let e = ClapError {error: "Error: could not parse integer fields!".to_owned(),
                                   error_type: ClapErrorType::ValueValidationError,};
                    
                return Err(e);
            },
        }
    }
    idx.sort_by(|a, b| a.0.cmp(&b.0));
    // check if there are duplicates
    {
        let mut it = idx.iter();
        let mut previous = match it.next() {
            Some(t) => t,
            None => {
                let e = ClapError {error: "Error: at least one key field expected!".to_owned(),
                                   error_type: ClapErrorType::ValueValidationError,};
                return Err(e);
            },
        };
        for current in it {
            if previous.0 == current.0 {
                let e = ClapError {error: "Error: the key fields must be unique!".to_owned(),
                                   error_type: ClapErrorType::ValueValidationError,};
                return Err(e);
            }
            previous = current;
        }
    }
    Ok(idx)
}

/// Extracts a key from the record.
///
/// # Safety
///
/// You should always use the `key_idx` parameter generated by `fields_to_idx()` function, unless
/// you know, what you're doing ;)
///
/// # Example
/// ```
/// use joinkit::util;
///
/// let rec = "a;b;c";
/// let field_sep = ";";
/// // this reads as follows: the first field goes to the second position and the third field goes
/// // to the first position.
/// let key_idx = [(0, 1), (2, 0)];
/// unsafe {
///     let key = util::extract_key(rec, field_sep, &key_idx);
///     assert_eq!(vec!["c".to_owned(), "a".to_owned()], key);
/// }
pub unsafe fn extract_key(record: &str, 
                   field_sep: &str,
                   key_idx: &[(usize, isize)],) -> Vec<String> { 
    let keys_len = key_idx.len();
    let mut keys: Vec<String> = Vec::with_capacity(keys_len);
    let p_keys = keys.as_mut_ptr();
    let mut actual_len = 0usize;
    {
        let key_idx_it = key_idx.iter();
        let key_fields_it = record.split(field_sep)
            .enumerate()
            // join on enumerated value and key_idx
            .merge_join_inner_by(key_idx_it, |l, r| Ord::cmp(&l.0, &r.0));
        mem::forget(keys);
        for ((_, k), &(_, i)) in key_fields_it {
            ptr::write(p_keys.offset(i), k.to_owned());
            actual_len += 1;
        }
        if actual_len != keys_len {
            panic!("Error during the key extraction: the key index exceeds the number of fields
                   in the record!");
        }
    }
    let keys = Vec::from_raw_parts(p_keys, keys_len, keys_len);
    keys
}

/// Extracts a key from the record and returns a tuple of the key and the record.
///
/// # Safety
///
/// You should always use the `key_idx` parameter generated by `fields_to_idx()` function, unless
/// you know, what you're doing ;)
///
/// # Example
/// ```
/// use std::borrow::Cow;
/// use joinkit::util;
///
/// let rec = "a;b;c";
/// let field_sep = ";";
/// // this reads as follows: the first field goes to the second position and the third field goes
/// // to the first position.
/// let key_idx = [(0, 1), (2, 0)];
/// unsafe {
///     let key_val = util::extract_key_value(rec, field_sep, &key_idx);
///     assert_eq!((vec!["c".to_owned(), "a".to_owned()], Cow::Borrowed("a;b;c")), key_val);
/// }
pub unsafe fn extract_key_value<'a, C>(record: C, 
                                field_sep: &str,
                                key_idx: &[(usize, isize)],) -> (Vec<String>, Cow<'a, str>) 
    where C: Into<Cow<'a, str>>,
{ 
    let record = record.into();
    let key = extract_key(&record, field_sep, key_idx);
    (key, record)
}

/// Returns a number of fields in the record.
///
/// #Example
/// ```
/// use joinkit::util;
///
/// let rec = "a;b;c;d";
/// let field_sep = ";";
/// let n = util::num_fields(rec, field_sep);
///
/// assert_eq!(4, n);
pub fn num_fields(record: &str, 
                  field_sep: &str,) -> usize {
    record.split(field_sep).count()
}

/// Writes both, the left value and the right value into output stream. 
///
/// The values are separated by the field separator and the record separator is appended at the
/// end.
pub fn write_both<W: Write>(stream: &mut BufWriter<W>, lv: &str, rv: &str, fs: &[u8], rs: &[u8]) {
    stream.write(lv.as_bytes()).expect("Error: could not write into output stream!");
    stream.write(fs).expect("Error: could not write into output stream!");
    stream.write(rv.as_bytes()).expect("Error: could not write into output stream!");
    stream.write(rs).expect("Error: could not write into output stream!");
}

/// Writes only the left value with padded field separators in place of missing right value. 
pub fn write_left<W: Write>(stream: &mut BufWriter<W>, lv: &str, r_len: usize, fs: &[u8], rs: &[u8]) {
    stream.write(lv.as_bytes()).expect("Error: could not write into output stream!");
    // pad field separators for empty fields
    for _ in 0..r_len {
        stream.write(fs).expect("Error: could not write into output stream!");
    }
    stream.write(rs).expect("Error: could not write into output stream!");
}

/// Writes only the right value with padded field separators in place of missing left value. 
pub fn write_right<W: Write>(stream: &mut BufWriter<W>, rv: &str, l_len: usize, fs: &[u8], rs: &[u8]) {
    // pad field separators for empty fields
    for _ in 0..l_len {
        stream.write(fs).expect("Error: could not write into output stream!");
    }
    stream.write(rv.as_bytes()).expect("Error: could not write into output stream!");
    stream.write(rs).expect("Error: could not write into output stream!");
}

