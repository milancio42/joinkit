<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `Joinkit` trait in crate `joinkit`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, Joinkit">

    <title>joinkit::Joinkit - Rust</title>

    <link rel="stylesheet" type="text/css" href="../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='index.html'>joinkit</a></p><script>window.sidebarCurrent = {name: 'Joinkit', ty: 'trait', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content trait">
<h1 class='fqn'><span class='in-band'>Trait <a href='index.html'>joinkit</a>::<wbr><a class='trait' href=''>Joinkit</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                [<span class='inner'>&#x2212;</span>]
            </a>
        </span><a id='src-3247' class='srclink' href='../src/joinkit/lib.rs.html#57-426' title='goto source code'>[src]</a></span></h1>
<pre class='rust trait'>pub trait Joinkit: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.Iterator.html' title='core::iter::Iterator'>Iterator</a> {
    fn <a href='#method.merge_join_inner_by' class='fnname'>merge_join_inner_by</a>&lt;R, F&gt;(self, other: R, cmp: F) -&gt; <a class='struct' href='../joinkit/struct.MergeJoinInner.html' title='joinkit::MergeJoinInner'>MergeJoinInner</a>&lt;Self, R::IntoIter, F&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a>, R: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>, F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(&amp;Self::<a class='trait' href='../joinkit/trait.Joinkit.html' title='joinkit::Joinkit'>Item</a>, &amp;R::Item) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html' title='core::cmp::Ordering'>Ordering</a></span> { ... }
    fn <a href='#method.merge_join_left_excl_by' class='fnname'>merge_join_left_excl_by</a>&lt;R, F&gt;(self, other: R, cmp: F) -&gt; <a class='struct' href='../joinkit/struct.MergeJoinLeftExcl.html' title='joinkit::MergeJoinLeftExcl'>MergeJoinLeftExcl</a>&lt;Self, R::IntoIter, F&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a>, R: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>, F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(&amp;Self::<a class='trait' href='../joinkit/trait.Joinkit.html' title='joinkit::Joinkit'>Item</a>, &amp;R::Item) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html' title='core::cmp::Ordering'>Ordering</a></span> { ... }
    fn <a href='#method.merge_join_left_outer_by' class='fnname'>merge_join_left_outer_by</a>&lt;R, F&gt;(self, other: R, cmp: F) -&gt; <a class='struct' href='../joinkit/struct.MergeJoinLeftOuter.html' title='joinkit::MergeJoinLeftOuter'>MergeJoinLeftOuter</a>&lt;Self, R::IntoIter, F&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a>, R: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>, F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(&amp;Self::<a class='trait' href='../joinkit/trait.Joinkit.html' title='joinkit::Joinkit'>Item</a>, &amp;R::Item) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html' title='core::cmp::Ordering'>Ordering</a></span> { ... }
    fn <a href='#method.merge_join_full_outer_by' class='fnname'>merge_join_full_outer_by</a>&lt;R, F&gt;(self, other: R, cmp: F) -&gt; <a class='struct' href='../joinkit/struct.MergeJoinFullOuter.html' title='joinkit::MergeJoinFullOuter'>MergeJoinFullOuter</a>&lt;Self, R::IntoIter, F&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a>, R: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>, F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(&amp;Self::<a class='trait' href='../joinkit/trait.Joinkit.html' title='joinkit::Joinkit'>Item</a>, &amp;R::Item) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html' title='core::cmp::Ordering'>Ordering</a></span> { ... }
    fn <a href='#method.hash_join_inner' class='fnname'>hash_join_inner</a>&lt;K, RI, RV&gt;(self, other: RI) -&gt; <a class='struct' href='../joinkit/struct.HashJoinInner.html' title='joinkit::HashJoinInner'>HashJoinInner</a>&lt;Self, K, RV&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a>, K: <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html' title='core::hash::Hash'>Hash</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html' title='core::cmp::Eq'>Eq</a>, RV: <a class='trait' href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a>, RI: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>&lt;Item=<a href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(K, RV)</a>&gt;</span> { ... }
    fn <a href='#method.hash_join_left_excl' class='fnname'>hash_join_left_excl</a>&lt;K, RI, RV&gt;(self, other: RI) -&gt; <a class='struct' href='../joinkit/struct.HashJoinLeftExcl.html' title='joinkit::HashJoinLeftExcl'>HashJoinLeftExcl</a>&lt;Self, K&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a>, K: <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html' title='core::hash::Hash'>Hash</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html' title='core::cmp::Eq'>Eq</a>, RI: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>&lt;Item=<a href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(K, RV)</a>&gt;</span> { ... }
    fn <a href='#method.hash_join_left_outer' class='fnname'>hash_join_left_outer</a>&lt;K, RI, RV&gt;(self, other: RI) -&gt; <a class='struct' href='../joinkit/struct.HashJoinLeftOuter.html' title='joinkit::HashJoinLeftOuter'>HashJoinLeftOuter</a>&lt;Self, K, RV&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a>, K: <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html' title='core::hash::Hash'>Hash</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html' title='core::cmp::Eq'>Eq</a>, RV: <a class='trait' href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a>, RI: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>&lt;Item=<a href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(K, RV)</a>&gt;</span> { ... }
    fn <a href='#method.hash_join_right_excl' class='fnname'>hash_join_right_excl</a>&lt;K, RI, RV&gt;(self, other: RI) -&gt; <a class='struct' href='../joinkit/struct.HashJoinRightExcl.html' title='joinkit::HashJoinRightExcl'>HashJoinRightExcl</a>&lt;Self, K, RV&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a>, K: <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html' title='core::hash::Hash'>Hash</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html' title='core::cmp::Eq'>Eq</a>, RI: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>&lt;Item=<a href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(K, RV)</a>&gt;</span> { ... }
    fn <a href='#method.hash_join_right_outer' class='fnname'>hash_join_right_outer</a>&lt;K, RI, RV&gt;(self, other: RI) -&gt; <a class='struct' href='../joinkit/struct.HashJoinRightOuter.html' title='joinkit::HashJoinRightOuter'>HashJoinRightOuter</a>&lt;Self, K, RV&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a>, K: <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html' title='core::hash::Hash'>Hash</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html' title='core::cmp::Eq'>Eq</a>, RV: <a class='trait' href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a>, RI: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>&lt;Item=<a href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(K, RV)</a>&gt;</span> { ... }
    fn <a href='#method.hash_join_full_outer' class='fnname'>hash_join_full_outer</a>&lt;K, RI, RV&gt;(self, other: RI) -&gt; <a class='struct' href='../joinkit/struct.HashJoinFullOuter.html' title='joinkit::HashJoinFullOuter'>HashJoinFullOuter</a>&lt;Self, K, RV&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a>, K: <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html' title='core::hash::Hash'>Hash</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html' title='core::cmp::Eq'>Eq</a>, RV: <a class='trait' href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a>, RI: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>&lt;Item=<a href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(K, RV)</a>&gt;</span> { ... }
}</pre><div class='docblock'><p>Trait <code>Joinkit</code> provides the extra iterator adaptors for efficient SQL-like joins.</p>
</div>
            <h2 id='provided-methods'>Provided Methods</h2>
            <div class='methods'>
        <h3 id='method.merge_join_inner_by' class='method stab '><code>fn <a href='#method.merge_join_inner_by' class='fnname'>merge_join_inner_by</a>&lt;R, F&gt;(self, other: R, cmp: F) -&gt; <a class='struct' href='../joinkit/struct.MergeJoinInner.html' title='joinkit::MergeJoinInner'>MergeJoinInner</a>&lt;Self, R::IntoIter, F&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a>, R: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>, F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(&amp;Self::<a class='trait' href='../joinkit/trait.Joinkit.html' title='joinkit::Joinkit'>Item</a>, &amp;R::Item) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html' title='core::cmp::Ordering'>Ordering</a></span></code></h3><div class='docblock'><p>Return an iterator adaptor that <a href="https://en.wikipedia.org/wiki/Join_%28SQL%29#Inner_join">inner
joins</a> the two input iterators in
ascending order. The resulting iterator is the intersection of the two input iterators.</p>

<p>The both input iterators must be sorted and unique on the join key (e.g. by
<a href="http://bluss.github.io/rust-itertools/doc/itertools/trait.Itertools.html#method.group_by">grouping</a>
them, if necessary) to produce the correct results.</p>

<p>Iterator element type is <code>(L::Item, R::Item)</code>.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>joinkit</span>::<span class='ident'>Joinkit</span>;

<span class='comment'>// tuples of (key, [value,...]), where the key is extracted from the value</span>
<span class='comment'>// notice the values are grouped by the key</span>
<span class='kw'>let</span> <span class='ident'>l</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='string'>&quot;0&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;0;A&quot;</span>]), (<span class='string'>&quot;1&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;1;B&quot;</span>])].<span class='ident'>into_iter</span>();
<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='string'>&quot;1&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;1;X&quot;</span>, <span class='string'>&quot;1;Y&quot;</span>]), (<span class='string'>&quot;2&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;2;Z&quot;</span>])].<span class='ident'>into_iter</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>l</span>.<span class='ident'>merge_join_inner_by</span>(<span class='ident'>r</span>, <span class='op'>|</span><span class='ident'>x</span>, <span class='ident'>y</span><span class='op'>|</span> <span class='ident'>Ord</span>::<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>x</span>.<span class='number'>0</span>, <span class='kw-2'>&amp;</span><span class='ident'>y</span>.<span class='number'>0</span>));

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>Some</span>(((<span class='string'>&quot;1&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;1;B&quot;</span>]), (<span class='string'>&quot;1&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;1;X&quot;</span>, <span class='string'>&quot;1;Y&quot;</span>]))));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>None</span>);</pre>
</div><h3 id='method.merge_join_left_excl_by' class='method stab '><code>fn <a href='#method.merge_join_left_excl_by' class='fnname'>merge_join_left_excl_by</a>&lt;R, F&gt;(self, other: R, cmp: F) -&gt; <a class='struct' href='../joinkit/struct.MergeJoinLeftExcl.html' title='joinkit::MergeJoinLeftExcl'>MergeJoinLeftExcl</a>&lt;Self, R::IntoIter, F&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a>, R: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>, F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(&amp;Self::<a class='trait' href='../joinkit/trait.Joinkit.html' title='joinkit::Joinkit'>Item</a>, &amp;R::Item) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html' title='core::cmp::Ordering'>Ordering</a></span></code></h3><div class='docblock'><p>Return an iterator adaptor that <em>left exclusive joins</em> the two input iterators in
ascending order. The resulting iterator contains only those records from the left input
iterator, which do not match the right input iterator. There is no direct equivalent in
SQL.</p>

<p>The both input iterators must be sorted and unique on the join key (e.g. by
<a href="http://bluss.github.io/rust-itertools/doc/itertools/trait.Itertools.html#method.group_by">grouping</a>
them, if necessary) to produce the correct results.</p>

<p>Iterator element type is <code>L::Item</code>.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>joinkit</span>::<span class='ident'>Joinkit</span>;

<span class='comment'>// tuples of (key, [value,...]), where the key is extracted from the value</span>
<span class='comment'>// notice the values are grouped by the key</span>
<span class='kw'>let</span> <span class='ident'>l</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='string'>&quot;0&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;0;A&quot;</span>]), (<span class='string'>&quot;1&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;1;B&quot;</span>])].<span class='ident'>into_iter</span>();
<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='string'>&quot;1&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;1;X&quot;</span>, <span class='string'>&quot;1;Y&quot;</span>]), (<span class='string'>&quot;2&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;2;Z&quot;</span>])].<span class='ident'>into_iter</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>l</span>.<span class='ident'>merge_join_left_excl_by</span>(<span class='ident'>r</span>, <span class='op'>|</span><span class='ident'>x</span>, <span class='ident'>y</span><span class='op'>|</span> <span class='ident'>Ord</span>::<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>x</span>.<span class='number'>0</span>, <span class='kw-2'>&amp;</span><span class='ident'>y</span>.<span class='number'>0</span>));

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>Some</span>((<span class='string'>&quot;0&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;0;A&quot;</span>])));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>None</span>);</pre>
</div><h3 id='method.merge_join_left_outer_by' class='method stab '><code>fn <a href='#method.merge_join_left_outer_by' class='fnname'>merge_join_left_outer_by</a>&lt;R, F&gt;(self, other: R, cmp: F) -&gt; <a class='struct' href='../joinkit/struct.MergeJoinLeftOuter.html' title='joinkit::MergeJoinLeftOuter'>MergeJoinLeftOuter</a>&lt;Self, R::IntoIter, F&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a>, R: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>, F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(&amp;Self::<a class='trait' href='../joinkit/trait.Joinkit.html' title='joinkit::Joinkit'>Item</a>, &amp;R::Item) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html' title='core::cmp::Ordering'>Ordering</a></span></code></h3><div class='docblock'><p>Return an iterator adaptor that <a href="https://en.wikipedia.org/wiki/Join_%28SQL%29#Left_outer_join">left outer
joins</a> the two input iterators
in ascending order. The resulting iterator contains all the records from the left input
iterator, even if they do not match the right input iterator.</p>

<p>The both input iterators must be sorted and unique on the join key (e.g. by
<a href="http://bluss.github.io/rust-itertools/doc/itertools/trait.Itertools.html#method.group_by">grouping</a>
them, if necessary) to produce the correct results.</p>

<p>Iterator element type is <a href="enum.EitherOrBoth.html"><code>EitherOrBoth&lt;L::Item, R::Item&gt;</code></a>.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>joinkit</span>::<span class='ident'>Joinkit</span>;
<span class='kw'>use</span> <span class='ident'>joinkit</span>::<span class='ident'>EitherOrBoth</span>::{<span class='ident'>Left</span>, <span class='ident'>Both</span>, <span class='ident'>Right</span>};

<span class='comment'>// tuples of (key, [value,...]), where the key is extracted from the value</span>
<span class='comment'>// notice the values are grouped by the key</span>
<span class='kw'>let</span> <span class='ident'>l</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='string'>&quot;0&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;0;A&quot;</span>]), (<span class='string'>&quot;1&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;1;B&quot;</span>])].<span class='ident'>into_iter</span>();
<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='string'>&quot;1&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;1;X&quot;</span>, <span class='string'>&quot;1;Y&quot;</span>]), (<span class='string'>&quot;2&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;2;Z&quot;</span>])].<span class='ident'>into_iter</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>l</span>.<span class='ident'>merge_join_left_outer_by</span>(<span class='ident'>r</span>, <span class='op'>|</span><span class='ident'>x</span>, <span class='ident'>y</span><span class='op'>|</span> <span class='ident'>Ord</span>::<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>x</span>.<span class='number'>0</span>, <span class='kw-2'>&amp;</span><span class='ident'>y</span>.<span class='number'>0</span>));

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>Some</span>(<span class='ident'>Left</span>((<span class='string'>&quot;0&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;0;A&quot;</span>]))));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>Some</span>(<span class='ident'>Both</span>((<span class='string'>&quot;1&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;1;B&quot;</span>]), (<span class='string'>&quot;1&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;1;X&quot;</span>, <span class='string'>&quot;1;Y&quot;</span>]))));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>None</span>);</pre>
</div><h3 id='method.merge_join_full_outer_by' class='method stab '><code>fn <a href='#method.merge_join_full_outer_by' class='fnname'>merge_join_full_outer_by</a>&lt;R, F&gt;(self, other: R, cmp: F) -&gt; <a class='struct' href='../joinkit/struct.MergeJoinFullOuter.html' title='joinkit::MergeJoinFullOuter'>MergeJoinFullOuter</a>&lt;Self, R::IntoIter, F&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a>, R: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>, F: <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.FnMut.html' title='core::ops::FnMut'>FnMut</a>(&amp;Self::<a class='trait' href='../joinkit/trait.Joinkit.html' title='joinkit::Joinkit'>Item</a>, &amp;R::Item) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html' title='core::cmp::Ordering'>Ordering</a></span></code></h3><div class='docblock'><p>Return an iterator adaptor that <a href="https://en.wikipedia.org/wiki/Join_%28SQL%29#Full_outer_join">full outer
joins</a> the two input iterators
in ascending order. The resulting iterator contains all the records from the both input
iterators.</p>

<p>The both input iterators must be sorted and unique on the join key (e.g. by
<a href="http://bluss.github.io/rust-itertools/doc/itertools/trait.Itertools.html#method.group_by">grouping</a>
them, if necessary) to produce the correct results.</p>

<p>Iterator element type is <a href="enum.EitherOrBoth.html"><code>EitherOrBoth&lt;L::Item, R::Item&gt;</code></a>.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>joinkit</span>::<span class='ident'>Joinkit</span>;
<span class='kw'>use</span> <span class='ident'>joinkit</span>::<span class='ident'>EitherOrBoth</span>::{<span class='ident'>Left</span>, <span class='ident'>Both</span>, <span class='ident'>Right</span>};


<span class='comment'>// tuples of (key, [value,...]), where the key is extracted from the value</span>
<span class='comment'>// notice the values are grouped by the key</span>
<span class='kw'>let</span> <span class='ident'>l</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='string'>&quot;0&quot;</span>,<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;0;A&quot;</span>]), (<span class='string'>&quot;1&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;1;B&quot;</span>])].<span class='ident'>into_iter</span>();
<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='string'>&quot;1&quot;</span>,<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;1;X&quot;</span>, <span class='string'>&quot;1;Y&quot;</span>]), (<span class='string'>&quot;2&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;2;Z&quot;</span>])].<span class='ident'>into_iter</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>l</span>.<span class='ident'>merge_join_full_outer_by</span>(<span class='ident'>r</span>, <span class='op'>|</span><span class='ident'>x</span>, <span class='ident'>y</span><span class='op'>|</span> <span class='ident'>Ord</span>::<span class='ident'>cmp</span>(<span class='kw-2'>&amp;</span><span class='ident'>x</span>.<span class='number'>0</span>, <span class='kw-2'>&amp;</span><span class='ident'>y</span>.<span class='number'>0</span>));

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>Some</span>(<span class='ident'>Left</span>((<span class='string'>&quot;0&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;0;A&quot;</span>]))));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>Some</span>(<span class='ident'>Both</span>((<span class='string'>&quot;1&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;1;B&quot;</span>]), (<span class='string'>&quot;1&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;1;X&quot;</span>, <span class='string'>&quot;1;Y&quot;</span>]))));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>Some</span>(<span class='ident'>Right</span>((<span class='string'>&quot;2&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;2;Z&quot;</span>]))));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>None</span>);</pre>
</div><h3 id='method.hash_join_inner' class='method stab '><code>fn <a href='#method.hash_join_inner' class='fnname'>hash_join_inner</a>&lt;K, RI, RV&gt;(self, other: RI) -&gt; <a class='struct' href='../joinkit/struct.HashJoinInner.html' title='joinkit::HashJoinInner'>HashJoinInner</a>&lt;Self, K, RV&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a>, K: <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html' title='core::hash::Hash'>Hash</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html' title='core::cmp::Eq'>Eq</a>, RV: <a class='trait' href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a>, RI: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>&lt;Item=<a href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(K, RV)</a>&gt;</span></code></h3><div class='docblock'><p>Return an iterator adaptor that <a href="https://en.wikipedia.org/wiki/Join_%28SQL%29#Inner_join">inner
joins</a> the two input iterators in
ascending order. The resulting iterator is the intersection of the two input iterators.</p>

<p>The input iterators do <em>not</em> need to be sorted. The right input iterator is loaded into
<code>HashMap</code> and grouped by the key automatically. Neither the left input iterator need to be
unique on the key.</p>

<p>The left input iterator element type must be <code>(K, LV)</code>, where <code>K: Hash + Eq</code>. 
The right input iterator element type must be <code>(K, RV)</code>, where <code>K: Hash + Eq</code> and <code>RV: Clone</code>.</p>

<p>When the join adaptor is created, the right iterator is <strong>consumed</strong> into <code>HashMap</code>.</p>

<p>Iterator element type is <code>(LV, vec![RV,...])</code>. 
The <code>RV</code> is cloned from <code>HashMap</code> for each joined value. A single <code>RV</code> can be expected to
be joined (and cloned) multiple times to <code>LV</code>. To increase performance, consider wrapping
<code>RV</code> into <code>std::rc::Rc</code> pointer to avoid unnecessary allocations.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>joinkit</span>::<span class='ident'>Joinkit</span>;

<span class='comment'>// tuples of (key, value), where the key is extracted from the value</span>
<span class='kw'>let</span> <span class='ident'>l</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='string'>&quot;0&quot;</span>, <span class='string'>&quot;0;A&quot;</span>), (<span class='string'>&quot;1&quot;</span>, <span class='string'>&quot;1;B&quot;</span>)].<span class='ident'>into_iter</span>();
<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='string'>&quot;1&quot;</span>, <span class='string'>&quot;1;X&quot;</span>), (<span class='string'>&quot;2&quot;</span>, <span class='string'>&quot;2;Z&quot;</span>), (<span class='string'>&quot;1&quot;</span>, <span class='string'>&quot;1;Y&quot;</span>)].<span class='ident'>into_iter</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>l</span>.<span class='ident'>hash_join_inner</span>(<span class='ident'>r</span>);

<span class='comment'>// notice the grouped right values</span>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>Some</span>((<span class='string'>&quot;1;B&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;1;X&quot;</span>, <span class='string'>&quot;1;Y&quot;</span>])));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>None</span>);</pre>
</div><h3 id='method.hash_join_left_excl' class='method stab '><code>fn <a href='#method.hash_join_left_excl' class='fnname'>hash_join_left_excl</a>&lt;K, RI, RV&gt;(self, other: RI) -&gt; <a class='struct' href='../joinkit/struct.HashJoinLeftExcl.html' title='joinkit::HashJoinLeftExcl'>HashJoinLeftExcl</a>&lt;Self, K&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a>, K: <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html' title='core::hash::Hash'>Hash</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html' title='core::cmp::Eq'>Eq</a>, RI: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>&lt;Item=<a href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(K, RV)</a>&gt;</span></code></h3><div class='docblock'><p>Return an iterator adaptor that <em>left exclusive joins</em> the two input iterators. The
resulting iterator contains only those records from the left input iterator, which do not
match the right input iterator. There is no direct equivalent in SQL.</p>

<p>The input iterators do <em>not</em> need to be sorted. The right input iterator is loaded into
<code>HashMap</code> and grouped by the key automatically. Neither the left input iterator need to be
unique on the key.</p>

<p>The left input iterator element type must be <code>(K, LV)</code>, where <code>K: Hash + Eq</code>. 
The right input iterator element type must be <code>(K, RV)</code>, where <code>K: Hash + Eq</code>.</p>

<p>When the join adaptor is created, the right iterator is <strong>consumed</strong> into <code>HashMap</code>.</p>

<p>Iterator element type is <code>LV</code>.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>joinkit</span>::<span class='ident'>Joinkit</span>;

<span class='comment'>// tuples of (key, value), where the key is extracted from the value</span>
<span class='kw'>let</span> <span class='ident'>l</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='string'>&quot;0&quot;</span>, <span class='string'>&quot;0;A&quot;</span>), (<span class='string'>&quot;1&quot;</span>, <span class='string'>&quot;1;B&quot;</span>)].<span class='ident'>into_iter</span>();
<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='string'>&quot;1&quot;</span>, <span class='string'>&quot;1;X&quot;</span>), (<span class='string'>&quot;2&quot;</span>, <span class='string'>&quot;2;Z&quot;</span>), (<span class='string'>&quot;1&quot;</span>, <span class='string'>&quot;1;Y&quot;</span>)].<span class='ident'>into_iter</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>l</span>.<span class='ident'>hash_join_left_excl</span>(<span class='ident'>r</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>Some</span>(<span class='string'>&quot;0;A&quot;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>None</span>);</pre>
</div><h3 id='method.hash_join_left_outer' class='method stab '><code>fn <a href='#method.hash_join_left_outer' class='fnname'>hash_join_left_outer</a>&lt;K, RI, RV&gt;(self, other: RI) -&gt; <a class='struct' href='../joinkit/struct.HashJoinLeftOuter.html' title='joinkit::HashJoinLeftOuter'>HashJoinLeftOuter</a>&lt;Self, K, RV&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a>, K: <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html' title='core::hash::Hash'>Hash</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html' title='core::cmp::Eq'>Eq</a>, RV: <a class='trait' href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a>, RI: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>&lt;Item=<a href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(K, RV)</a>&gt;</span></code></h3><div class='docblock'><p>Return an iterator adaptor that <a href="https://en.wikipedia.org/wiki/Join_%28SQL%29#Left_outer_join">left outer
joins</a> the two input
iterators.  The resulting iterator contains all the records from the left input iterator,
even if they do not match the right input iterator.</p>

<p>The input iterators do <em>not</em> need to be sorted. The right input iterator is loaded into
<code>HashMap</code> and grouped by the key automatically. Neither the left input iterator need to be
unique on the key.</p>

<p>The left input iterator element type must be <code>(K, LV)</code>, where <code>K: Hash + Eq</code>. 
The right input iterator element type must be <code>(K, RV)</code>, where <code>K: Hash + Eq</code> and <code>RV: Clone</code>.</p>

<p>When the join adaptor is created, the right iterator is <strong>consumed</strong> into <code>HashMap</code>.</p>

<p>Iterator element type is <a href="enum.EitherOrBoth.html"><code>EitherOrBoth&lt;LV, RV&gt;</code></a>.
The <code>RV</code> is cloned from <code>HashMap</code> for each joined value. It is expected a single <code>RV</code> will
be joined (and cloned) multiple times to <code>LV</code>. To increase performance, consider wrapping
<code>RV</code> into <code>std::rc::Rc</code> pointer to avoid unnecessary allocations.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>joinkit</span>::<span class='ident'>Joinkit</span>;
<span class='kw'>use</span> <span class='ident'>joinkit</span>::<span class='ident'>EitherOrBoth</span>::{<span class='ident'>Left</span>, <span class='ident'>Both</span>, <span class='ident'>Right</span>};

<span class='comment'>// tuples of (key, value), where the key is extracted from the value</span>
<span class='kw'>let</span> <span class='ident'>l</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='string'>&quot;0&quot;</span>, <span class='string'>&quot;0;A&quot;</span>), (<span class='string'>&quot;1&quot;</span>, <span class='string'>&quot;1;B&quot;</span>)].<span class='ident'>into_iter</span>();
<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='string'>&quot;1&quot;</span>, <span class='string'>&quot;1;X&quot;</span>), (<span class='string'>&quot;2&quot;</span>, <span class='string'>&quot;2;Z&quot;</span>), (<span class='string'>&quot;1&quot;</span>, <span class='string'>&quot;1;Y&quot;</span>)].<span class='ident'>into_iter</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>l</span>.<span class='ident'>hash_join_left_outer</span>(<span class='ident'>r</span>);

<span class='comment'>// notice the grouped right values</span>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>Some</span>(<span class='ident'>Left</span>(<span class='string'>&quot;0;A&quot;</span>)));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>Some</span>(<span class='ident'>Both</span>(<span class='string'>&quot;1;B&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;1;X&quot;</span>, <span class='string'>&quot;1;Y&quot;</span>])));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>None</span>);</pre>
</div><h3 id='method.hash_join_right_excl' class='method stab '><code>fn <a href='#method.hash_join_right_excl' class='fnname'>hash_join_right_excl</a>&lt;K, RI, RV&gt;(self, other: RI) -&gt; <a class='struct' href='../joinkit/struct.HashJoinRightExcl.html' title='joinkit::HashJoinRightExcl'>HashJoinRightExcl</a>&lt;Self, K, RV&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a>, K: <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html' title='core::hash::Hash'>Hash</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html' title='core::cmp::Eq'>Eq</a>, RI: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>&lt;Item=<a href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(K, RV)</a>&gt;</span></code></h3><div class='docblock'><p>Return an iterator adaptor that <em>right exclusive joins</em> the two input iterators. The resulting
iterator contains only those records from the right input iterator, which do not match the
left input iterator. There is no direct equivalent in SQL.</p>

<p>The input iterators do <em>not</em> need to be sorted. The right input iterator is loaded into
<code>HashMap</code> and grouped by the key automatically. Neither the left input iterator need to be
unique on the key.</p>

<p>The left input iterator element type must be <code>(K, LV)</code>, where <code>K: Hash + Eq</code>. 
The right input iterator element type must be <code>(K, RV)</code>, where <code>K: Hash + Eq</code>.</p>

<p>When the join adaptor is created, the right iterator is <strong>consumed</strong> into <code>HashMap</code>.</p>

<p>Iterator element type is <code>vec![RV,...]</code>.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>joinkit</span>::<span class='ident'>Joinkit</span>;

<span class='comment'>// tuples of (key, value), where the key is extracted from the value</span>
<span class='kw'>let</span> <span class='ident'>l</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='string'>&quot;0&quot;</span>, <span class='string'>&quot;0;A&quot;</span>), (<span class='string'>&quot;1&quot;</span>, <span class='string'>&quot;1;B&quot;</span>)].<span class='ident'>into_iter</span>();
<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='string'>&quot;1&quot;</span>, <span class='string'>&quot;1;X&quot;</span>), (<span class='string'>&quot;2&quot;</span>, <span class='string'>&quot;2;Z&quot;</span>), (<span class='string'>&quot;1&quot;</span>, <span class='string'>&quot;1;Y&quot;</span>)].<span class='ident'>into_iter</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>l</span>.<span class='ident'>hash_join_right_excl</span>(<span class='ident'>r</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>Some</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;2;Z&quot;</span>]));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>None</span>);</pre>
</div><h3 id='method.hash_join_right_outer' class='method stab '><code>fn <a href='#method.hash_join_right_outer' class='fnname'>hash_join_right_outer</a>&lt;K, RI, RV&gt;(self, other: RI) -&gt; <a class='struct' href='../joinkit/struct.HashJoinRightOuter.html' title='joinkit::HashJoinRightOuter'>HashJoinRightOuter</a>&lt;Self, K, RV&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a>, K: <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html' title='core::hash::Hash'>Hash</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html' title='core::cmp::Eq'>Eq</a>, RV: <a class='trait' href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a>, RI: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>&lt;Item=<a href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(K, RV)</a>&gt;</span></code></h3><div class='docblock'><p>Return an iterator adaptor that <a href="https://en.wikipedia.org/wiki/Join_%28SQL%29#Right_outer_join">right outer
joins</a> the two input
iterators.  The resulting iterator contains all the records from the right input iterator,
even if they do not match the left input iterator.</p>

<p>The input iterators do <em>not</em> need to be sorted. The right input iterator is loaded into
<code>HashMap</code> and grouped by the key automatically. Neither the left input iterator need to be
unique on the key.</p>

<p>The left input iterator element type must be <code>(K, LV)</code>, where <code>K: Hash + Eq</code>. 
The right input iterator element type must be <code>(K, RV)</code>, where <code>K: Hash + Eq</code> and <code>RV: Clone</code>.</p>

<p>When the join adaptor is created, the right iterator is <strong>consumed</strong> into <code>HashMap</code>.</p>

<p>Iterator element type is <a href="enum.EitherOrBoth.html"><code>EitherOrBoth&lt;LV, RV&gt;</code></a>.
The <code>RV</code> is cloned from <code>HashMap</code> for each joined value. It is expected a single <code>RV</code> will
be joined (and cloned) multiple times to <code>LV</code>. To increase performance, consider wrapping
<code>RV</code> into <code>std::rc::Rc</code> pointer to avoid unnecessary allocations.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>joinkit</span>::<span class='ident'>Joinkit</span>;
<span class='kw'>use</span> <span class='ident'>joinkit</span>::<span class='ident'>EitherOrBoth</span>::{<span class='ident'>Left</span>, <span class='ident'>Both</span>, <span class='ident'>Right</span>};

<span class='comment'>// tuples of (key, value), where the key is extracted from the value</span>
<span class='kw'>let</span> <span class='ident'>l</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='string'>&quot;0&quot;</span>, <span class='string'>&quot;0;A&quot;</span>), (<span class='string'>&quot;1&quot;</span>, <span class='string'>&quot;1;B&quot;</span>)].<span class='ident'>into_iter</span>();
<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='string'>&quot;1&quot;</span>, <span class='string'>&quot;1;X&quot;</span>), (<span class='string'>&quot;2&quot;</span>, <span class='string'>&quot;2;Z&quot;</span>), (<span class='string'>&quot;1&quot;</span>, <span class='string'>&quot;1;Y&quot;</span>)].<span class='ident'>into_iter</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>l</span>.<span class='ident'>hash_join_right_outer</span>(<span class='ident'>r</span>);

<span class='comment'>// notice the grouped right values</span>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>Some</span>(<span class='ident'>Both</span>(<span class='string'>&quot;1;B&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;1;X&quot;</span>, <span class='string'>&quot;1;Y&quot;</span>])));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>Some</span>(<span class='ident'>Right</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;2;Z&quot;</span>])));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>None</span>);</pre>
</div><h3 id='method.hash_join_full_outer' class='method stab '><code>fn <a href='#method.hash_join_full_outer' class='fnname'>hash_join_full_outer</a>&lt;K, RI, RV&gt;(self, other: RI) -&gt; <a class='struct' href='../joinkit/struct.HashJoinFullOuter.html' title='joinkit::HashJoinFullOuter'>HashJoinFullOuter</a>&lt;Self, K, RV&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a>, K: <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html' title='core::hash::Hash'>Hash</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html' title='core::cmp::Eq'>Eq</a>, RV: <a class='trait' href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a>, RI: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>&lt;Item=<a href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(K, RV)</a>&gt;</span></code></h3><div class='docblock'><p>Return an iterator adaptor that <a href="https://en.wikipedia.org/wiki/Join_%28SQL%29#Full_outer_join">full outer
joins</a> the two input
iterators.  The resulting iterator contains all the records from the both input iterators.</p>

<p>The input iterators do <em>not</em> need to be sorted. The right input iterator is loaded into
<code>HashMap</code> and grouped by the key automatically. Neither the left input iterator need to be
unique on the key.</p>

<p>The left input iterator element type must be <code>(K, LV)</code>, where <code>K: Hash + Eq</code>. 
The right input iterator element type must be <code>(K, RV)</code>, where <code>K: Hash + Eq</code> and <code>RV: Clone</code>.</p>

<p>When the join adaptor is created, the right iterator is <strong>consumed</strong> into <code>HashMap</code>.</p>

<p>Iterator element type is <a href="enum.EitherOrBoth.html"><code>EitherOrBoth&lt;LV, RV&gt;</code></a>.
The <code>RV</code> is cloned from <code>HashMap</code> for each joined value. It is expected a single <code>RV</code> will
be joined (and cloned) multiple times to <code>LV</code>. To increase performance, consider wrapping
<code>RV</code> into <code>std::rc::Rc</code> pointer to avoid unnecessary allocations.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>joinkit</span>::<span class='ident'>Joinkit</span>;
<span class='kw'>use</span> <span class='ident'>joinkit</span>::<span class='ident'>EitherOrBoth</span>::{<span class='ident'>Left</span>, <span class='ident'>Both</span>, <span class='ident'>Right</span>};

<span class='comment'>// tuples of (key, value), where the key is extracted from the value</span>
<span class='kw'>let</span> <span class='ident'>l</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='string'>&quot;0&quot;</span>, <span class='string'>&quot;0;A&quot;</span>), (<span class='string'>&quot;1&quot;</span>, <span class='string'>&quot;1;B&quot;</span>)].<span class='ident'>into_iter</span>();
<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[(<span class='string'>&quot;1&quot;</span>, <span class='string'>&quot;1;X&quot;</span>), (<span class='string'>&quot;2&quot;</span>, <span class='string'>&quot;2;Z&quot;</span>), (<span class='string'>&quot;1&quot;</span>, <span class='string'>&quot;1;Y&quot;</span>)].<span class='ident'>into_iter</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>it</span> <span class='op'>=</span> <span class='ident'>l</span>.<span class='ident'>hash_join_full_outer</span>(<span class='ident'>r</span>);

<span class='comment'>// notice the grouped right values</span>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>Some</span>(<span class='ident'>Left</span>(<span class='string'>&quot;0;A&quot;</span>)));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>Some</span>(<span class='ident'>Both</span>(<span class='string'>&quot;1;B&quot;</span>, <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;1;X&quot;</span>, <span class='string'>&quot;1;Y&quot;</span>])));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>Some</span>(<span class='ident'>Right</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;2;Z&quot;</span>])));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>it</span>.<span class='ident'>next</span>(), <span class='prelude-val'>None</span>);</pre>
</div></div>
        <h2 id='implementors'>Implementors</h2>
        <ul class='item-list' id='implementors-list'>
    </ul><script type="text/javascript" async
                              src="../implementors/joinkit/trait.Joinkit.js">
                      </script></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "joinkit";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script async src="../search-index.js"></script>
</body>
</html>